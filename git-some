#!/usr/bin/env bash
#
# Generates git commits using randomly-named files, one file per commit.
#
# USAGE: git-some <number of commits to generate>

# Fail script if something goes wrong.
set -o errexit

# Treat unset variables as an error, and immediately exit.
set -o nounset

# Default to 1 commit unless specified otherwise.
commit_count=${1-1}

# Limit to 100 files (file-00.txt to file-99.txt).
commit_limit=100
max_index=$((commit_limit - 1))

if ! [[ "$commit_count" =~ ^[0-9]+$ ]]; then
  >&2 printf 'Need a positive number for number of commits to generate, got: %s\n' \
    "$commit_count"

  exit 1
fi

placeholder_length=${#max_index}
printf -v search_pattern '%*s' "$placeholder_length" ''
search_pattern="file-${search_pattern// /?}.txt"

shopt -s nullglob
# shellcheck disable=SC2206
files=($search_pattern)
file_count=${#files[@]}
if ((file_count + commit_count >= max_index)); then
  >&2 printf 'Cannot create %s file(s). %s file(s) are permitted and %s file(s) have already been created. %s file(s) left.\n' \
             "$commit_count" \
             "$commit_limit" \
             "$file_count" \
             "$((commit_limit - file_count))"

  exit 3
fi

for ((commit = 1; commit <= commit_count; commit++)); do
  # Try to find an untaken file between 0 and ($commit_limit - 1).
  while true; do
    number=$((RANDOM % commit_limit))
    printf -v filename "file-%0*d.txt" "$placeholder_length" "$number"

    [[ -f "$filename" ]] || break
  done

  # Create file.
  printf 'contents for %s\n' "$filename" > "$filename"

  # Stage file.
  if ! git add -- "$filename"; then
    rm -f -- "$filename"
    exit 2
  fi

  # Create commit.
  if ! git commit --message "commit message for $filename"; then
    git rm --force -- "$filename" > /dev/null
    exit 4
  fi

  printf '\n'
done

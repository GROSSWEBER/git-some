#!/usr/bin/env bash
#
# Generates git commits using randomly-named files, one file per commit.
#
# USAGE: git-some <number of commits to generate>

# Fail script if something goes wrong.
set -o errexit

# Treat unset variables as an error, and immediately exit.
set -o nounset

options="\
%s
%s [number of commits]
%s [--message=<prefix>] [number of commits]

Create a number of random commits. By default, one commit is created.

Every commit will create a file with a random name. The file name pattern
is \"file-XX.txt\", where \"XX\" is a randomly generated number between 0 and 99.

The commit message includes the current branch name (or \"detached HEAD\").
Optionally you can define a commit message prefix using the --message switch.
--
h,help          Show the help
m,message=prefix An optional commit message prefix"

# shellcheck disable=SC2059
printf -v options "$options" "${0##*/}" "${0##*/}" "${0##*/}"

eval "$(git rev-parse --parseopt -- "$@" <<< "$options" || echo exit $?)"

while (($# > 0)); do
  opt="$1"
  shift

  case "$opt" in
    -m)
      message="$1"
      shift
      ;;

    --)
      # Default to 1 commit unless specified otherwise.
      commit_count="${1-1}"

      if ! [[ "$commit_count" =~ ^[0-9]+$ ]]; then
        >&2 printf 'Need a positive number for number of commits to generate, got: %s\n' \
                   "$commit_count"

        exit 1
      fi

      break
      ;;

    *)
      >&2 printf 'Unexpected option: %s\n' "$opt"
      exit 1
      ;;
  esac
done

# Limit to 100 files (file-00.txt to file-99.txt).
commit_limit=100
max_index=$((commit_limit - 1))

placeholder_length=${#max_index}
printf -v search_pattern '%*s' "$placeholder_length" ''
search_pattern="file-${search_pattern// /?}.txt"

shopt -s nullglob
# shellcheck disable=SC2206
files=($search_pattern)
file_count=${#files[@]}
if ((file_count + commit_count >= max_index)); then
  >&2 printf 'Cannot create %s file(s). %s file(s) are permitted and %s file(s) have already been created. %s file(s) left.\n' \
             "$commit_count" \
             "$commit_limit" \
             "$file_count" \
             "$((commit_limit - file_count))"

  exit 3
fi

if [[ ! -v message ]]; then
  message="$(git symbolic-ref --quiet --short HEAD || printf 'detached HEAD')"
fi

for ((commit = 1; commit <= commit_count; commit++)); do
  # Try to find an untaken file between 0 and ($commit_limit - 1).
  while true; do
    number=$((RANDOM % commit_limit))
    printf -v filename "file-%0*d.txt" "$placeholder_length" "$number"

    [[ -f "$filename" ]] || break
  done

  # Create file.
  printf 'contents for %s\n' "$filename" > "$filename"

  # Stage file.
  if ! git add -- "$filename"; then
    rm -f -- "$filename"
    exit 2
  fi

  # Create commit.
  if ! git commit --message "$message: $filename"; then
    git rm --force -- "$filename" > /dev/null
    exit 4
  fi

  printf '\n'
done
